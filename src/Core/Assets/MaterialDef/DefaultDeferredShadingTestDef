// 测试默认延迟渲染路径
Def DefaultDeferredShadingTestDef{
    Params{
        vec4 color;
    }
    SubTechnology GreenColorPass{
        Vars{
            vec4 fragPos;
        }
        Vs_Shader{
            void main(){
                //Context.OutPosition = Context.ProjectViewMatrix * Context.ModelMatrix * vec4(Context.InPosition, 1.0f);
                Context.OutPosition = Context.ProjectMatrix * Context.ViewMatrix * Context.ModelMatrix * vec4(Context.InPosition, 1.0f);
                //fragPos = Context.OutPosition.xyz;
            }
        }
        Fs_Shader{
            void main(){
                Context.OutColor = vec4(0.0f, 1.0f, 0.0f, 1.0f);
            }
        }
    }
    SubTechnology GBufferPass{
        Vars{
            vec3 fragPos;
        }
        Vs_Shader{
            void main(){
                vec4 worldPos = Context.ModelMatrix * vec4(Context.InPosition, 1.0f);
                Context.OutPosition = Context.ProjectViewMatrix * worldPos;
                //Context.OutPosition = Context.ProjectMatrix * Context.ViewMatrix * Context.ModelMatrix * vec4(Context.InPosition, 1.0f);
                fragPos = worldPos.xyz;
            }
        }
        Fs_Shader{
            void main(){
                Context.OutGPosition = fragPos;
                Context.OutGNormal = vec3(1.0f, 0.2f, 0.2f);
                Context.OutGAlbedoSpec.rgb = vec3(1.0f, 0.0f, 0.0f);
                Context.OutGAlbedoSpec.a = 1.0f;
                //Context.OutGDepth = vec4(1.0f);
                float far=gl_DepthRange.far;
                float near=gl_DepthRange.near;

                float ndc_depth = gl_FragCoord.z / gl_FragCoord.w;

                float depth = (((far-near) * ndc_depth) + near + far) / 2.0;
                Context.OutGDepth = vec4(depth);
            }
        }
    }
    SubTechnology DeferredShadingPass{
        Vars{
            vec4 wordPosition;
            vec2 uv0;
        }
        Vs_Shader{
            void main(){
                Context.OutPosition = vec4(Context.InPosition, 1.0f);
                wordPosition = Context.OutPosition;
                uv0 = Context.InUv0;
            }
        }
        Fs_Shader{
            void main(){
                vec3 pos = texture(Context.InGPosition, uv0).rgb;
                //vec3 norm = texture(Context.InGNormal, vec2(0.5f, 0.5f)).rgb;
                Context.OutColor = vec4(pos, 1.0f);
                //gl_FragDepth = texture(Context.InGDepth, uv0).r;
                //gl_FragDepth = 0.0f;
                //Context.OutColor = vec4(gl_FragDepth, gl_FragDepth, gl_FragDepth, 1.0f);
                //Context.OutColor = vec4(vec3(1.0f, 0, 0), 1.0f);
                //Context.OutColor = texture(Context.InGAlbedoSpec, uv0).rgba;
                //Context.OutColor = vec4(1.0f, 0.0f, 0.0f, 1.0f);
            }
        }
    }
    Technology{
        Sub_Pass{
            Pass GreenColorPass{
            }
        }
    }
    Technology TestDeferredShading{
        Sub_Pass DeferredShading{
            Pass GBufferPass{
            }
            Pass DeferredShadingPass{
            }
        }
    }
}
