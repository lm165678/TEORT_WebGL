// 原理化光照材质定义
Def PrincipledLightingDef{
    Params{
        vec4 baseColor;
        float metallic;
        float roughness;
        // 自发光
        vec4 emissive;
        float emissivePower;
        // 自发光强度
        float emissiveIntensity;
        sampler2D baseColorMap;
        // metallic管线
        sampler2D normalMap;
        sampler2D metallicRoughnessMap;
        sampler2D metallicMap;
        sampler2D roughnessMap;
        // specular管线
        bool useSpecGloss;
        sampler2D specularGlossinessMap;
        sampler2D specularMap;
        sampler2D glossinessMap;
        vec4 specular;
        float glossiness;

        // alphaDiscard
        float alphaDiscard;
    }
    SubTechnology SPPrincipledLighting{
        Vars{
            vec3 wNormal;
            vec3 wPosition;
            vec2 wUv0;
            mat3 tbnMat;
        }
        Advanced{
            RenderProgram SinglePassLighting;
        }
        Vs_Shader{
            void main(){
                #ifdef Context.Skins
                    mat4 skinMat =
                            Context.InWeight0.x * Context.Joints[int(Context.InJoint0.x)] +
                            Context.InWeight0.y * Context.Joints[int(Context.InJoint0.y)] +
                            Context.InWeight0.z * Context.Joints[int(Context.InJoint0.z)] +
                            Context.InWeight0.w * Context.Joints[int(Context.InJoint0.w)];
                    vec4 pos = Context.ModelMatrix * skinMat * vec4(Context.InPosition, 1.0f);
                #else
                    vec4 pos = Context.ModelMatrix * vec4(Context.InPosition, 1.0f);
                #endif


                wPosition = (Context.ModelMatrix * vec4(Context.InPosition, 1.0f)).xyz;
                mat3 nMat = mat3(transpose(inverse(Context.ModelMatrix)));
                vec3 norm = normalize(nMat * Context.InNormal);
                vec3 t = normalize(nMat * Context.InTangent);
                t = normalize(t - dot(t, norm) * norm);
                vec3 b = cross(norm, t);
                tbnMat = mat3(t, b, norm);
                wNormal = norm;
                wUv0 = Context.InUv0;


                Context.OutPosition = Context.ProjectViewMatrix * pos;
            }
        }

        Fs_Shader{
            // 计算光照方向
            // 对于DirLight,PointLight以及SpotLight,lightType依次为0.0,1.0,2.0
            // 输出光照方向
            // lightDir.w存储衰减率(对于DirLight,衰减值一直为1,对于Point或Spot,衰减值随着半径而变小,衰减值越小,表示衰减度越大)
            void ComputeLightDir(in vec3 worldPos, in float lightType, in vec4 position, out vec4 lightDir, out vec3 lightVec){
                // 只有lightType = 0.0时,posLight为0.0,否则posLight为1.0
                float posLight = step(0.5f, lightType);

                // 计算光照位置
                // 对于DirLight,lightVec = position.xyz * sign(-0.5f) = position.xyz * -1.0f;其中position代表DirLight的方向
                // 对于PointLight和SpotLight,lightVec = position.xyz * sign(1.0f - 0.5f) - (worldPos * 1.0f) = positions.xyz * 1.0f - worldPos;其中position代表Light的位置
                lightVec = position.xyz * sign(posLight - 0.5f) - (worldPos * posLight);
                float dist = length(lightVec);

                // 对于DirLight,lightDir.w = 1.0f
                lightDir.w = clamp(1.0f - position.w * dist * posLight, 0.0f, 1.0f);

                //lightDir.w = (1.0f - position.w * dist) / (1.0f + position.w * dist * dist);
                //lightDir.w = clamp(lightDir.w, 1.0f - posLight, 1.0f);

                // 归一化
                lightDir.xyz = lightVec / vec3(dist);
            }
            #define PI 3.14159265358979323846264
            // 镜面反射菲涅尔计算
            vec3 F_Shlick(float vh,	vec3 F0){
            	float fresnelFact = pow(2.0f, (-5.55473f * vh - 6.98316f) * vh);
            	return mix(F0, vec3(1.0f, 1.0f, 1.0f), fresnelFact);
            }
            vec3 F_Schlick2(float cosTheta, vec3 F0)
            {
                return F0 + (1.0f - F0) * pow(1.0f - cosTheta, 5.0f);
            }
            // 计算直接光照
            vec3 ComputeDirectLighting(in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in vec3 diffuseColor, in vec3 fZero, in float roughness, in float ndotv, out vec3 directLighting){
                vec3 h = normalize(lightDir + viewDir);
                float ndotl = max( dot( normal, lightDir ), 0.0f );
                float ndoth = max( dot( normal, h), 0.0f );
                float hdotv = max( dot( h, viewDir ), 0.0f );

                // 这里,不使用c/Π计算diffuse fr(x, wi, wo)
                // 而假设恒定
                vec3 diffuse = vec3( ndotl ) * lightColor * diffuseColor;

                // cook-torrence,BRDF : http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf
                float alpha = roughness * roughness;

                // D, GGX 法线分布函数
                float alpha2 = alpha * alpha;
                float sum = (( ndoth * ndoth ) * ( alpha2 - 1.0f ) + 1.0f);
                // 似乎这里D项直接输出与标准PBR不同,单独输出PI,sum和sum都是正常,唯独计算后的D与标准PBR比对不一致
                // 所以这里PI * 0.2f
                float denom = PI * 0.2f * sum * sum;
                float D = alpha2 / denom;

                // F, 菲涅尔项
                vec3 F = F_Shlick( hdotv, fZero );

                // G, 几何遮挡项
                float k = alpha * 0.5f;
                float G_V = ndotv + sqrt( ( ndotv - ndotv * k ) * ndotv + k );
                float G_L = ndotl + sqrt( ( ndotl - ndotl * k ) * ndotl + k );
                float G = 1.0f / max( G_V * G_L ,0.01f );

                // specularBRDF
                float t = D * G * ndotl;
                vec3 specular =  vec3( t ) * F * lightColor;

                directLighting = diffuse + specular;
                return vec3( D * G );
            }
            // 返回Spot范围衰减
            float ComputeSpotFalloff(in vec4 spotDirection, in vec3 lightDir){
                float curAngleCos = dot(lightDir, -spotDirection.xyz);
                float innerAngleCos = floor(spotDirection.w) * 0.001f;
                float outerAngleCos = fract(spotDirection.w);
                float innerMinusOuter = innerAngleCos - outerAngleCos;
                float falloff = clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0f, 1.0f);
                //if(curAngleCos > innerMinusOuter)
                //    falloff = 1.0f;
                //else
                //    falloff = 0.0f;

                #ifdef SRGB
                    // Use quadratic falloff (notice the ^4)
                    return pow(clamp((curAngleCos - outerAngleCos) / innerMinusOuter, 0.0, 1.0), 4.0);
                #else
                    // Use linear falloff
                    return falloff;
                #endif
            }
            void main(){
                // 计算光照
                vec4 lightColor;
                vec4 lightData1;
                vec4 lightDir = vec4(0.0f);
                vec3 lightVec = vec3(0.0f);
                vec3 directLighting = vec3(0.0f);
                vec3 viewDir = normalize(Context.CameraPosition.xyz - wPosition.xyz);

                #ifdef Params.baseColor
                    #ifdef Params.baseColorMap
                        vec4 albedo = texture(Params.baseColorMap, wUv0) * Params.baseColor;
                    #else
                        vec4 albedo = Params.baseColor;
                    #endif
                #else
                    #ifdef Params.baseColorMap
                        vec4 albedo = texture(Params.baseColorMap, wUv0);
                    #else
                        vec4 albedo = vec4(1.0f);
                    #endif
                #endif

                #ifdef Params.alphaDiscard
                    if(albedo.a < Params.alphaDiscard){
                        discard;
                    }
                #endif

                vec3 normal = wNormal;
                #ifdef Params.normalMap
                    vec3 normalHeight = texture(Params.normalMap, wUv0).xyz;
                    normal = tbnMat * normalize(normalHeight * 2.0f - 1.0f);
                #endif

                #ifdef Params.metallicRoughnessMap
                    vec2 rm = texture(Params.metallicRoughnessMap, wUv0).gb;
                    #ifdef Params.roughness
                        float _roughness = rm.x * max(Params.roughness, 1e-4);
                    #else
                        float _roughness = rm.x;
                    #endif
                    #ifdef Params.metallic
                        float _metallic = rm.y * max(Params.metallic, 0.0f);
                    #else
                        float _metallic = rm.y;
                    #endif
                #else
                    #ifdef Params.roughnessMap
                        #ifdef Params.roughness
                            float _roughness = texture(Params.roughnessMap, wUv0).r * max(Params.roughness, 1e-4);
                        #else
                            float _roughness = texture(Params.roughnessMap, wUv0).r;
                        #endif
                    #else
                        #ifdef Params.roughness
                            float _roughness = max(Params.roughness, 1e-4);
                        #else
                            float _roughness = 1.0f;
                        #endif
                    #endif
                    #ifdef Params.metallicMap
                        #ifdef Params.metallic
                            float _metallic = texture(Params.metallicMap, wUv0).r * max(Params.metallic, 0.0f);
                        #else
                            float _metallic = texture(Params.metallicMap, wUv0).r;
                        #endif
                    #else
                        #ifdef Params.metallic
                            float _metallic = max(Params.metallic, 0.0f);
                        #else
                            float _metallic = 1.0f;
                        #endif
                    #endif
                #endif

                #ifdef Params.useSpecGloss
                    #ifdef Params.specularGlossinessMap
                        vec4 _specularColor = texture(Params.specularGlossinessMap, wUv0);
                        #ifdef Params.glossiness
                            float _glossiness = _specularColor.a * Params.glossiness;
                        #else
                            float _glossiness = _specularColor.a;
                        #endif
                        #ifdef Params.specular
                            _specularColor *= Params.specular;
                        #endif
                    #else
                        #ifdef Params.specularMap
                            vec4 _specularColor = texture(Params.specularMap, wUv0);
                        #else
                            vec4 _specularColor = vec4(1.0f);
                        #endif
                        #ifdef Params.specular
                            _specularColor *= Params.specular;
                        #endif
                        #ifdef Params.glossinessMap
                            #ifdef Params.glossiness
                                float _glossiness = texture(Params.glossinessMap, wUv0).r * Params.glossiness;
                            #else
                                float _glossiness = texture(Params.glossinessMap, wUv0).r;
                            #endif
                        #else
                            float _glossiness = 1.0f;
                        #endif
                    #endif
                    vec4 _diffuseColor = albedo;
                    _roughness = 1.0f - _glossiness;
                    vec3 fZero = _specularColor.rgb;
                #else
                    float nonMetalSpec = 0.04f;
                    vec4 _specularColor = (nonMetalSpec - nonMetalSpec * _metallic) + albedo * _metallic;
                    vec4 _diffuseColor = albedo - albedo * _metallic;
                    vec3 fZero = vec3( 0.5f );
                #endif

                float ndotv = max( dot( normal, viewDir ), 0.0f );
                for( int i = 0;i < Context.CurLightCount;i+=3 ){
                    lightColor = Context.WLightData[i];
                    lightData1 = Context.WLightData[i + 1];
                    ComputeLightDir(wPosition, lightColor.w, lightData1, lightDir, lightVec);

                    // 计算PointLight的衰减
                    float spotFallOff = 1.0 * lightDir.w;
                    // 计算SpotLight的衰减
                    if( lightColor.w > 1.0f )
                    {
                        // 计算SpotLight的范围衰减
                        spotFallOff = ComputeSpotFalloff( Context.WLightData[i + 2], lightDir.xyz );
                    }

                    vec3 diff = ComputeDirectLighting(normal, viewDir, lightDir.xyz, lightColor.rgb, _diffuseColor.rgb, fZero, _roughness, ndotv, directLighting);
                    Context.OutColor.rgb += directLighting * spotFallOff;
                    //Context.OutColor.rgb = diff;
                }
                Context.OutColor.a = albedo.a;

            }
        }
    }

    Technology{
        Sub_Pass{
            Pass SPPrincipledLighting{
            }
        }
    }
}
